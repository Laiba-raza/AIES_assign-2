# -*- coding: utf-8 -*-
"""CT-22003_ASSIGNMENT#2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bAWwb_ihrrU6VKOZjkLRhu57Q9v71sfY

CLASS FOR TIC TAC TOE
"""

class TicTacToe:
    def __init__(self):
        self.board = [' ' for _ in range(9)]  # 3x3 board in a single list

    def print_board(self):
        for row in [self.board[i*3:(i+1)*3] for i in range(3)]:
            print('| ' + ' | '.join(row) + ' |')

    def is_winner(self, player):
        b = self.board
        win_cond = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns
            [0, 4, 8], [2, 4, 6]              # Diagonals
        ]
        return any(all(b[i] == player for i in cond) for cond in win_cond)

    def is_draw(self):
        return ' ' not in self.board and not self.is_winner('X') and not self.is_winner('O')

    def available_moves(self):
        return [i for i, val in enumerate(self.board) if val == ' ']

    def make_move(self, index, player):
        if self.board[index] == ' ':
            self.board[index] = player
            return True
        return False

    def undo_move(self, index):
        self.board[index] = ' '

"""STANDARD MINIMAX ALGORITHM"""

def minimax(game, depth, is_maximizing):
    if game.is_winner('X'):
        return 1
    elif game.is_winner('O'):
        return -1
    elif game.is_draw():
        return 0

    if is_maximizing:
        best_score = -float('inf')
        for move in game.available_moves():
            game.make_move(move, 'X')
            score = minimax(game, depth + 1, False)
            game.undo_move(move)
            best_score = max(best_score, score)
        return best_score
    else:
        best_score = float('inf')
        for move in game.available_moves():
            game.make_move(move, 'O')
            score = minimax(game, depth + 1, True)
            game.undo_move(move)
            best_score = min(best_score, score)
        return best_score

def best_move_minimax(game):
    best_score = -float('inf')
    move = None
    for i in game.available_moves():
        game.make_move(i, 'X')
        score = minimax(game, 0, False)
        game.undo_move(i)
        if score > best_score:
            best_score = score
            move = i
    return move

"""Alpha-Beta Pruning Optimization"""

def minimax_ab(game, depth, alpha, beta, is_maximizing):
    if game.is_winner('X'):
        return 1
    elif game.is_winner('O'):
        return -1
    elif game.is_draw():
        return 0

    if is_maximizing:
        best_score = -float('inf')
        for move in game.available_moves():
            game.make_move(move, 'X')
            score = minimax_ab(game, depth + 1, alpha, beta, False)
            game.undo_move(move)
            best_score = max(best_score, score)
            alpha = max(alpha, score)
            if beta <= alpha:
                break
        return best_score
    else:
        best_score = float('inf')
        for move in game.available_moves():
            game.make_move(move, 'O')
            score = minimax_ab(game, depth + 1, alpha, beta, True)
            game.undo_move(move)
            best_score = min(best_score, score)
            beta = min(beta, score)
            if beta <= alpha:
                break
        return best_score

def best_move_ab(game):
    best_score = -float('inf')
    move = None
    for i in game.available_moves():
        game.make_move(i, 'X')
        score = minimax_ab(game, 0, -float('inf'), float('inf'), False)
        game.undo_move(i)
        if score > best_score:
            best_score = score
            move = i
    return move

"""Performance Comparision"""

counter_minimax = 0
counter_ab = 0

def minimax_count(game, depth, is_maximizing):
    global counter_minimax
    counter_minimax += 1

def minimax_ab_count(game, depth, alpha, beta, is_maximizing):
    global counter_ab
    counter_ab += 1